#define _WINSOCK_DEPRECATED_NO_WARNINGS

#include <cstdio>
#include <tchar.h>
#include <string>
#include <thread>
#include <chrono>
#include <future>
#include <WinSock2.h>
#include <WS2tcpip.h>

// 라이브러리 링크
#pragma comment(lib, "WS2_32.lib")
#define MAX_USER            200

// 서버에 접속한 클라이언트 정보
struct User
{
    SOCKET socket;                 // 클라이언트 소켓
    TCHAR ip[16];                   // 클라이언트 주소
};

class AsyncServer
{
public:
    // 생성자
    explicit AsyncServer()
    {
        WSADATA wsaData;
        (void)WSAStartup(0x0202, &wsaData);                     // 라이브러리 실행

        for (int i = 0; i < MAX_USER; i++)
        {
            m_user[i].socket = INVALID_SOCKET;
        }
        m_server_socket = INVALID_SOCKET;
    }

    // 파괴자
    virtual ~AsyncServer()
    {
        User* p = m_user;
        for (int i = 0; i < MAX_USER; i++, p++)
        {
            if (p->socket != INVALID_SOCKET) {
                closesocket(p->socket);
                p->socket = INVALID_SOCKET;
            }
        }

        if (m_server_socket != INVALID_SOCKET) {
            closesocket(m_server_socket);
            m_server_socket = INVALID_SOCKET;
        }

        WSACleanup();
    }

    // 서버를 시작하는 함수 (비동기)
    void StartListen(int a_port)
    {
        // 소켓 생성
        m_server_socket = socket(AF_INET, SOCK_STREAM, 0);

        m_server_address.sin_family = AF_INET;
        m_server_address.sin_port = htons(a_port);
        m_server_address.sin_addr.S_un.S_addr = INADDR_ANY;

        // 네트워크 연결
        bind(m_server_socket, (sockaddr*)&m_server_address, sizeof(m_server_address));
        
        // 서버 시작
        listen(m_server_socket, 5);

        // 비동기로 accept() 실행
        m_accept_future = std::async(std::launch::async, &AsyncServer::AcceptClient, this);
    }

    void AcceptClient()
    {
        while (true) {
            // 클라이언트 정보
            sockaddr_in client_address;
            int client_address_size = sizeof(client_address);

            // 연결 수락
            SOCKET client_socket = accept(m_server_socket, (sockaddr*)&client_address, &client_address_size);

            TCHAR ip_address[16];
            InetNtop(AF_INET, &client_address.sin_addr, ip_address, 16);
            _tprintf(_T("클라이언트 접속 %s\n"), ip_address);

            for (int i = 0; i < MAX_USER; i++)
            {
                if (m_user[i].socket == INVALID_SOCKET)
                {
                    m_user[i].socket = client_socket;
                    _tcscpy_s(m_user[i].ip, 16, ip_address);

                    // 비동기로 해당 클라이언트에 대해 recv 실행
                    m_recv_future = std::async(std::launch::async, &AsyncServer::RecvMsg, this, client_socket);
                    break;
                }
            }
        }
    }

    // 메시지 수신 (비동기)
    void RecvMsg(SOCKET clientSocket)
    {
        while (true)
        {
            char buffer[1024];
            memset(buffer, 0, sizeof(buffer));
            TCHAR wbuffer[1024] = { 0, };

            // 메시지 수신
            int read = recv(clientSocket, buffer, sizeof(buffer), 0);
            if (read > 0)
            {
                A2Wpchar(buffer, wbuffer);
                User* p = m_user;
                TCHAR ip[16];
                for (int i = 0; i < MAX_USER; i++)
                {
                    if (p->socket == clientSocket)
                    {
                        memcpy(ip, p->ip, sizeof(p->ip));
                    }
                }
                _tprintf(_T("\n %s : %s \n"), ip, wbuffer);
            }
            else if (read == 0)
            {
                printf("클라이언트 정상 종료 \n");
                break;
            }
            else if(read == SOCKET_ERROR)
            {
                printf("클라이언트 강제 종료 \n");
                break;
            }
            else
            {
                printf("Error\n");
                break;
            }
        }
        CloseSocketClient(clientSocket);
    }

    void CloseSocketClient(SOCKET a_client_socket)
    {
        User* p = m_user;
        User* target_client = NULL;

        // 해당 유저를 찾아
        for (int i = 0; i < MAX_USER; i++, p++)
        {
            if(p->socket == a_client_socket)
            {
                target_client = m_user + i;
                closesocket(a_client_socket);               // 종료시킨다
            }
        }
        
        // 정보도 삭제한다
        if (target_client != NULL)
        {
            target_client->socket = INVALID_SOCKET;
            memset(target_client->ip, 0, sizeof(target_client->ip));
        }
    }

    // 메시지 모든 사용자에게 보내기
    void SendBroadcast(const char* a_msg)
    {
        int msg_len = strlen(a_msg);
        char* data = new char[msg_len+1];
        memset(data, 0, msg_len+1);
        memcpy(data, a_msg, msg_len);

        User* p = m_user;
        for (int i = 0; i < MAX_USER; i++, p++)
        {
            if (p->socket != INVALID_SOCKET) {
                send(p->socket, data, msg_len, 0);
                //printf("\n나이거보냄>>%s<<\n", data);
            }
        }
        delete[] data;
    }

    // 메시지 보내기
    void SendToClient(SOCKET a_socket, const char* a_msg)
    {
        int msg_len = strlen(a_msg);
        char* data = new char[msg_len];
        memcpy(data, a_msg, msg_len);

        send(a_socket, data, msg_len, 0);
        delete[] data;
    }

    // UTF-8일 경우 CP_ACP를 CP_UTF8로 변경하기

    /*
    멀티바이트에서 유니코드로 변환 (char)
    */
    void A2Wpchar(const char* const p_char, wchar_t* const p_wchar)
    {
        int origin_len = strlen(p_char);
        int len = MultiByteToWideChar(CP_ACP, 0, p_char, origin_len, NULL, NULL);
        MultiByteToWideChar(CP_ACP, 0, p_char, origin_len, p_wchar, len);
    }

    /*
    유니코드에서 멀티바이트로 변환 (char)
    */
    void W2Apchar(const wchar_t* const p_wchar, char* const p_char)
    {
        int len = WideCharToMultiByte(CP_ACP, 0, p_wchar, -1, NULL, 0, NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, p_wchar, -1, p_char, len, NULL, NULL);
    }

private:
    User m_user[MAX_USER];
    SOCKET m_server_socket = INVALID_SOCKET;
    sockaddr_in m_server_address;

    std::future<void> m_accept_future;
    std::future<void> m_recv_future;
    std::future<void> m_send_future;
};

int main()
{
    _tsetlocale(0, _T("korean"));
    char server_msg[256] = { 0, };
    AsyncServer asyncServer;

    asyncServer.StartListen(8888);

    while (true)
    {
        //std::this_thread::sleep_for(std::chrono::seconds(1));
        printf("클라이언트 전체에 보낼 메시지>>");
        rewind(stdin);
        scanf_s("%[^\n]s", server_msg, 256);

        // 객체의 메서드를 비동기 처리
        std::future<void> future = std::async(std::launch::async, std::bind(&AsyncServer::SendBroadcast, &asyncServer, server_msg));
    }


}

